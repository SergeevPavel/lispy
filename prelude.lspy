; Drawbacks and notices:
; 1. No functions with zero arguments
; 2. Maybe it's good idea to rewrite if function to format if {cond} {then} {else}
; 3. What is correct way to break control flow?
; 4. Implement correct closures
; 5. Implementation ffi for calling C functions is very vaguely.
;    But we can try implement interaction with forieng code in python-like style.
;    Provide way to write external modules in C, that can use part of internals
;    data types of interpretaror. And importing some additional C implemented functions.
;    Modules may be implemented as *.so libraries, that loaded by interpreter in runtime.

;
; Define atoms
;

(def {nil} {})

(def {fun} (\{args body} {
  def (head args) (\(tail args) body)
}))

;
; Logic
;

(def {true} 1)
(def {false} 0)

(fun {not x} {(- x 1)})
(fun {and x y} {(* x y)})
(fun {or x y} {(+ x y)})

;
; List tools
;
(fun {fst l} {
  eval (head l)
})

(fun {len l} {
  if (== l nil)
    { 0 }
    { + (len (tail l)) 1 }
})

(fun {nth n l} {
  if (== n 0)
    { fst l }
    { nth (- n 1) (tail l) }
})

(fun {take n l} {
  if (== n 0)
    { nil }
    { join (head l) (take (- n 1) (tail l)) }
})

(fun {drop n l} {
  if (== n 0)
    { l }
    { drop (- n 1) (tail l) }
})

(fun {split n l} {
  list (take n l) (drop n l)
})

(fun {last l} {
  nth (- (len l) 1) l
})

;
; Control flow
;

; Try to replace with Haskell style do notation
(fun {do & l} {
  if (== l nil)
    { nil }
    { last l }
})

(fun {for ind min max body} {
  do (fun {_for i} {
    if (< i max)
      { do (= ind i) (eval body) (_for (+ i 1)) }
      nil
  }) (_for min)
})

(fun {while cond body} {
  if (eval cond)
    { do (eval body) (while cond body) }
    nil
})

;
; Math
;

(fun {sqr x} {
  (* x x)
})

(fun {fib n} {
  if (< n 2)
    {1}
    {+ (fib (- n 1)) (fib (- n 2))}
})



; This function polute global namespace
; beacause no way to access to local variable from nested functions
(fun {is_prime x} {
  (do
    (def {d} 2)
    (def {r} true)
    (while {and (>= x (sqr d)) r} {
      (do
        (if (% x d) {} { (def {r} false) } )
        (def {d} (+ d 1))
        )
    })
    r)
})

(fun {print_primes max} {
  (for {i} 2 max {
    if (is_prime i) {print i} {}
  })
})

; Closures working not properly
; Evironment binds to function in calling moment it leads to following problems:
; 1. We can't use closures
; 2. When we use recursion for iteration serching symbol in global space is very time consuming
(fun {make_adder n} {
  \{y} {+ n y}
})

(def {inc} (make_adder 1))
(int 42) ; Unbound Symbol 'n'

; 5.43 seconds
; python 0.02 seconds. 280x faster
;(print_primes 1000)
